if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
View(perImagePeakAu)
View(peakM)
dim(aupeakMatrix)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 10))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
View(perImagePeakAu)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
View(perImagePeakAu)
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
View(perImagePeakAu)
View(perImagePeakAu)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
View(perImagePeakAu)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 10))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
View(perImagePeakAu)
# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/"
# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"
# Insert the group for each image (control, control, problem, ...) in order
groupsImg <- c("Control1", "Control2", "Transition1", "Transition2", "Tumor1", "Tumor2")
# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/"
# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"
# Insert the group for each image (control, control, problem, ...) in order
groupsImg <- c("Control1", "Control2", "Transition1", "Transition2", "Tumor1", "Tumor2")
# Here we extract the Peak Matrix from the .zip and create and object with all the data assigned to peakM
peakM <- rMSIproc::LoadPeakMatrix(file.path(wDir, peakData))
# If your peak matrix is composed of multiple images this will separate them in multiple peak matrix
matrixList <- list()
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
matrixList[[i]] <- rMSIproc::`[.rMSIprocPeakMatrix`(peakM, int)
}
matrixList <- matrixList[c(1,2,5,6,3,4)]
peakM <- rMSIproc::MergePeakMatrices(matrixList)
View(peakM)
## This function searches the peak matrix for the intensities of the gold peaks with teorical mass auTList
auTList <- c(196.966570, 393.933140, 590.899710, 787.866280, 984.832850)
rmIndex <- sapply(auTList, function(tMass){
diffMatrix <- (abs(peakM$mass - tMass))
index <- which.min(diffMatrix)
return(index) ## This will return the masses where the gold peaks are based on the real mass                                                 ## with the minimum difference with the teorical mass
})
auMass <- peakM$mass[rmIndex]
#########################
##
# rmIndex2 <- sapply(auTList, function(tMass){
#   diffMatrix <- (abs(tMass - peakM$mass)/tMass*10^6)
#   index <- which(diffMatrix < 50)
#   return(index)
#   })
# auMass50 <- peakM$mass[rmIndex2]
#########################
## All intensities from every Au peak
aupeakMatrix <- peakM$intensity[,rmIndex]
aunames <- c("Au1", "Au2","Au3", "Au4","Au5")
colnames(aupeakMatrix) <- aunames
# anotation <- rMSIproc::peakAnnotation(PeakMtx = peakM)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 10))/length(aupeakMatrix[int,z])*100
}
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 10))/length(aupeakMatrix[int,z])*100
}
colnames(perImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
View(perImagePeakAu)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 5))/length(aupeakMatrix[int,z])*100
}
colnames(perImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
View(perImagePeakAu)
perImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
for(z in 1:length(auTList)){
perImagePeakAu[i,z] <-  length(which(aupeakMatrix[int,z] > 1))/length(aupeakMatrix[int,z])*100
}
colnames(perImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}
View(peakM)
View(peakM)
apply(peakM$intensity, 1, max)
View(peakM)
a <- apply(peakM$intensity, 1, max)
max(a)
View(peakM)
max(a)
peakM$mass
max(a)
a <- apply(peakM$intensity, 1, max)
View(peakM)
max(a)
peakM[["mass"]]
View(matrixList)
View(aupeakMatrix)
auTList
rMSIproc::plotPeakImage(peakMatrix = peakM, mz = 30)
anotation <- rMSIproc::peakAnnotation(PeakMtx = peakM)
setwd(wDir)
rMSIproc::plotPeakImage(peakMatrix = peakM, mz = 1)
peakM$mass - 100
abs(peakM$mass - 100)
which.min(abs(peakM$mass - 100))
peakM$mass[15]
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 15      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1,3) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
print(rMSIproc::plotPeakImageG(peakMatrix = peakM,mass = 30))
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 15      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
print(rMSIproc::plotPeakImageG(peakMatrix = peakM,mass = 30))
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 15      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100      #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 99     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 400     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 120     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 122     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 200     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
rMSIproc::plotPeakImageG(matrixList[[1]], 100)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1) #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
rMSIproc::plotPeakImageG(matrixList[[1]], 100)
plotly::ggplotly(rMSIproc::plotPeakImageG(matrixList[[1]], 100))
mzIndex <- which.min(abs(peakM$mass - 100))
rMSIproc::plotPeakImageG(matrixList[[1]], mzIndex)
rMSIproc::plotPeakImageG(matrixList[[1]], 15)
rMSIproc::plotPeakImageG(matrixList[[1]], 100)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1)   #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100     #Tip. You can find all the mz in your data using peakM$mass
img2plot <- c(1)   #Tip. Writing a vector c() allows you to plot more images at the same time
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)
pl <- lapply(1:length(img2plot), function(i){
plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2Plot2 <- 2  #
centring <- T
scaling  <- T
dataRaw <- peakM$intensity
# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/"
# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"
# Insert the group for each image (control, control, problem, ...) in the order it was input on rMSIproc
# Note # If left empty each image will be named Img1,Img2...
groupsImg <- c("Control1", "Control2", "Transition1", "Transition2", "Tumor1", "Tumor2")
peakM <- rMSIproc::LoadPeakMatrix(file.path(wDir, peakData))
# If your peak matrix is composed of multiple images this will separate them in multiple peak matrix
matrixList <- list()
for(i in 1:length(peakM$numPixels)){
limitDown <- sum(peakM$numPixels[1:(i-1)])+1
limitUp <- sum(peakM$numPixels[1:i])
if(i == 1){limitDown <- 1}
int <- limitDown:limitUp
matrixList[[i]] <- rMSIproc::`[.rMSIprocPeakMatrix`(peakM, int)
}
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2Plot2 <- 2  #
centring <- T
scaling  <- T
dataRaw <- peakM$intensity
colnames(dataRaw) <- peakM$mass
pcaRaw <- prcomp(dataRaw, center = centring, scale. = scaling) ### Fem la PCA de la matriu de pics
listGroups <- mapply(function(groups,i){
rep(groups,  peakM$numPixels[i])
}, groupsImg, 1:length(groupsImg))
vectorGroups <- unlist(listGroups)
pcaData <- list()
pcaData[[1]] <- pcaRaw$x[,pc2plot1]
pcaData[[2]] <- pcaRaw$x[,pc2plot2]
pc2plot2 <- 2  #
pcaData[[2]] <- pcaRaw$x[,pc2plot2]
pcaData[[3]] <- vectorGroups
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:5333)
sdev <-pcaRaw$sdev/sum(pcaRaw$sdev)*100
ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
ggplot2::ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
library(ggplot2)
ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
?plotValuesImage
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pcaPlotter <- function(peakMatrix, pc1, pc2, cnt, scl, grpImg , normalization = NA){
dataRaw <- peakMatrix$intensity
if(normalization == "TIC"){dataRaw/peakMatrix$normalization$TIC}
if(normalization == "RMS"){dataRaw/peakMatrix$normalization$RMS}
if(normalization == "AcqTic"){dataRaw/peakMatrix$normalization$AcqTic}
if(!is.na(normalization) && (!(normalization %in% c( "TIC", "RMS", "AcqTic")))){stop("The normalization value is not one of the list. Check you've written it correctly or if you don't want to normalize the data write a NA in normalization")}
colnames(dataRaw) <- peakMatrix$mass
pcaRaw <- prcomp(dataRaw, center = cnt, scale. = scl) ### Fem la PCA de la matriu de pics
listGroups <- mapply(function(groups,i){
rep(groups,  peakMatrix$numPixels[i])
}, grpImg, 1:length(grpImg))
vectorGroups <- unlist(listGroups)
pcaData <- list()
pcaData[[1]] <- pcaRaw$x[,pc1]
pcaData[[2]] <- pcaRaw$x[,pc2]
pcaData[[3]] <- vectorGroups
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:5333)
sdev <-pcaRaw$sdev/sum(pcaRaw$sdev)*100
ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
}
pcaPlotter(peakM, 1, 2, T, T, groupsImg, "Tic")
pcaPlotter(peakM, 1, 2, T, T, groupsImg, "TIC")
toupper("tic")
toupper(NA)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
length(dataPca$PC1)
length(dataPca$PC2)
length(dataPca$Groups)
dataPca$Groups
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  #
centering <- T
scaling  <- T
normalization <- NA
pcaPlotter(pc2plot1, pc2plot2, centering, scaling, normalization)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pcaPlotter(pc2plot1, pc2plot2, centering, scaling, normalization)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pcaPlotter(pc2plot1, pc2plot2, centering, scaling, normalization)
View(peakM)
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  #
centering <- T
scaling  <- T
normalization <- NA
pcaPlotter(peakMatrix = peakM, pc1 =  pc2plot1, pc2 = pc2plot2, centering, scaling, normalization)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  #
centering <- T
scaling  <- T
normalization <- NA
pcaPlotter(peakMatrix = peakM, pc1 =  pc2plot1, pc2 = pc2plot2, centering, scaling, normalization)
pcaPlotter <- function(peakMatrix, pc1, pc2, cnt, scl, grpImg , normalization = NA){
dataRaw <- peakMatrix$intensity
toupper(normalization)
if(!is.na(normalization)){
if(normalization == "TIC"){dataRaw/peakMatrix$normalization$TIC}
else if(normalization == "RMS"){dataRaw/peakMatrix$normalization$RMS}
else if(normalization == "ACQTIC"){dataRaw/peakMatrix$normalization$AcqTic}
else {stop("The normalization value is not one of the list. Check you've written it correctly or if you don't want to normalize the data write a NA in normalization")}
}
colnames(dataRaw) <- peakMatrix$mass
pcaRaw <- prcomp(dataRaw, center = cnt, scale. = scl) ### Fem la PCA de la matriu de pics
listGroups <- mapply(function(groups,i){
rep(groups,  peakMatrix$numPixels[i])
}, grpImg, 1:length(grpImg))
vectorGroups <- unlist(listGroups)
pcaData <- list()
pcaData[[1]] <- pcaRaw$x[,pc1]
pcaData[[2]] <- pcaRaw$x[,pc2]
pcaData[[3]] <- vectorGroups
browser()
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:length(dataPca$PC1))
sdev <-pcaRaw$sdev/sum(pcaRaw$sdev)*100
ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
}
pcaPlotter(peakMatrix = peakM, pc1 =  pc2plot1, pc2 = pc2plot2, centering, scaling, normalization)
View(pcaData)
pcaData[[3]]
Q
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pcaPlotter <- function(peakMatrix, pc1, pc2, cnt, scl, grpImg , normalization = NA){
dataRaw <- peakMatrix$intensity
toupper(normalization)
if(!is.na(normalization)){
if(normalization == "TIC"){dataRaw/peakMatrix$normalization$TIC}
else if(normalization == "RMS"){dataRaw/peakMatrix$normalization$RMS}
else if(normalization == "ACQTIC"){dataRaw/peakMatrix$normalization$AcqTic}
else {stop("The normalization value is not one of the list. Check you've written it correctly or if you don't want to normalize the data write a NA in normalization")}
}
colnames(dataRaw) <- peakMatrix$mass
pcaRaw <- prcomp(dataRaw, center = cnt, scale. = scl) ### Fem la PCA de la matriu de pics
listGroups <- mapply(function(groups,i){
rep(groups,  peakMatrix$numPixels[i])
}, grpImg, 1:length(grpImg))
vectorGroups <- unlist(listGroups)
pcaData <- list()
pcaData[[1]] <- pcaRaw$x[,pc1]
pcaData[[2]] <- pcaRaw$x[,pc2]
pcaData[[3]] <- vectorGroups
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:length(dataPca$PC1))
sdev <-pcaRaw$sdev/sum(pcaRaw$sdev)*100
ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) +  xlab(paste0("PC1", sdev[pc2plot1])) + ylab(paste0("PC1", sdev[pc2Plot2]))
}
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  #
centering <- T
scaling  <- T
normalization <- NA
pcaPlotter(peakMatrix = peakM, pc1 =  pc2plot1, pc2 = pc2plot2, centering, scaling, groupsImg, normalization)
trunc(sdev)
round(sdev, 4)
round(sdev, 3)
round(sdev, 4)
sdev <- round(pcaRaw$sdev/sum(pcaRaw$sdev)*100)
source('~/GitHub/rMSIteachings/initialPlotter.R', echo=TRUE)
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  #
centering <- T
scaling  <- T
normalization <- NA
pcaPlotter(peakMatrix = peakM, pc1 =  pc2plot1, pc2 = pc2plot2, centering, scaling, groupsImg, normalization)
