---
title: "rMSIproc analysis"
author: "Jordi Rofes"
date: "`r Sys.Date()`"
output: html_document
---

### Introduction
rMSI and rMSIproc are R packages that allow the visualization of MALDIims data (rMSI) and the data processing from all the pixel spectrums to a peak matrix (rMSIproc). This tutorial wants to provide a standardized workflow for scientists analyzing different rMSIproc peak matrixs obtained from different images. This tutorial will explain how to: explore the peak matrix to visualize the different m/z intensities on the images, what normalization steps should be utilized when comparing different peak matrix, how to visualize the medium spectrum of the raw data, the application of multidimensional reduction methods (PCA), the utilization of clustering methods like Kmeans and SOM to find clusters of similar spectrums that can be related to differences between different tissue zones and the visualization and comparison of those clusters.

### Required Packages
For this tutorial you will need to install [rMSI](https://github.com/prafols/rMSI), [rMSIproc](https://github.com/prafols/rMSIproc), [ggplot2](https://github.com/tidyverse/ggplot2), [plotly](https://github.com/plotly/dashR) packages if you don't have them.

### rMSI
```{r}
# This function opens the rMSI user interface that allows you to visualize a chosen image
rMSI::OpenMSI()
```
### rMSIproc
```{r}
# This function opens the rMSIproc user interface.
# rMSIproc allows you to input multiple rMSI images to process them (peak peaking, binning, aligning, baseline correction # and calibration) and outputs a compressed file with the peak matrix with the intensities of each mass bin for every    
# pixel on the image  
rMSIproc::ProcessWizard()

```

### Preparations

```{r message=FALSE, warning=FALSE}

# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/"
# Insert here where your the document initialPlotter.R is located
dir2 <- "C:/Users/jordi/Documents/GitHub/rMSIteachings/"
# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"


source(paste0(dir2, "initialPlotter.R")) # This sources all the functions we will need
library(ggplot2)
library(plotly)


```

### Extracting the Peak Matrix

```{r results = "hide", echo = "false"}

# Here we extract the Peak Matrix from the .zip and create and object with all the data assigned to peakM
peakM <- rMSIproc::LoadPeakMatrix(file.path(wDir, peakData))


# If your peak matrix is composed of multiple images this will separate them in multiple peak matrix
matrixList <- sepMatrix(peakM)

peakM$names 
```

### Order changing

```{r}
# If you are not happy with the order of the images showed on peakM$names you can change it's order by entering here a  
# vector with the desired order of images. This will update the peakM object with the new order

newOrder <- c(1,2,5,6,3,4) # Insert here the new desired order and run the code chunk. It will require some time to finish

matrixList <- matrixList[newOrder]
peakM <- rMSIproc::MergePeakMatrices(matrixList)
```


###  Assigning groups

```{r}
# To allow classification of the images in different groups you will need to insert the names of each group in the vector groupsImg in the order they are on the peak matrix

peakM$names # This allows you to see the order of the images on the peak matrix

# Insert the group for each image (control, control, problem, ...) in the order they are on the peak matrix
# Note # If you input NA. Each group will have the name in peakM$names
groupsImg <- c("Tumor1", "Tumor2", "Healthy1", "Healthy2", "Transition1", "Transition2")

paste0(rep("Control",10),1:10) #If you have many images per experimental group you may want to use an expression like this


if(length(groupsImg) != length(peakM$names)){
  stop("Be careful. The number of groups is not equal to the number of images. Every image should have a group assigned")
}

```

### Exploring the peak matrix

```{r echo=FALSE, warning=FALSE}

# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100            # You can find all the mz in your data using peakM$mass
img2plot <- c(2,3)        # Writing a vector c() allows you to plot more images at the same time. Input a 0 to plot all the images 
normalization <- peakM$normalizations$TIC  # Input here a vector with the normalization values. Input NA for no normalization.
save <- F                 # Choose if you want to save the plots into a pdf file (T/F)
fileN <- "plotsRAW.pdf"   # Choose the name of the pdf file. If a file has the same name it will be overwritten


initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg, normalization, save, fileN)


```

### Normalizations

Data normalization is a key step to remove part of the systematical error so the data represents more the biological variation
  There are several ways to normalize the data:
     TIC (Total Ion Count): TIC divides every pixel by the mean of all mass intesities of the raw data.
     AcqTic (Acquired TIC): Acquired TIC calculates the TIC of each pixel and then calculates a mean with the surrounding TICs.
     RMS (Root Mean Squares): RMS divides each pixel by the root mean square of all mass intensities. 


### Medium Spectrum from raw data

```{r}
# We can use rMSI functions to plot the average spectra of an image to explore the raw data
# Make sure that the .tar of the images is on the same directory you are working on
medSpec <- medSpecRaw(wDir)

```

```{r message=FALSE, warning=FALSE}
# Here we plot the average spectrums we want to compare
avSpecimg2plot <- c(1)      # Select the images you want to compare. Writing c(1,2,3) allows you to plot more than 
                            # one image at the same time

library(ggplot2)
library(plotly)
medSpecRawplot(medSpec , avSpecimg2plot)

```

### Medium spectrum from peak matrix from selected pixels
```{r}
# This function makes the medium spectrum from selectec pixels from the peak matrix

pixels2compare <- c(1:50)   # Input the first set of pixels that are going to be compared
pixels2compare2 <- c(51:100)# Input the second set of pixels that are going to be compared 
                            
name1 <- "Cortex"           # Insert a tag for the first set of pixels
name2 <- "Medula"           # Insert a tag for the second set of pixels
normalization <- peakM$normalizations$TIC   # Choose between TIC/RMS/AcqTic normalizations. Leave it NA for no normalization
save1 <- F                  # Choose if you want to save the plots into a pdf file (T/F)
fileName1 <- ".pdf"         # Choose the name of the pdf file. If a file has the same name it will be overwritten

medSpecComp(peakM, pixels2compare, pixels2compare2, normalization, name1, name2, save1, fileName1)


```

### PCA

```{r echo=FALSE, message=FALSE, warning=FALSE}
centering<- T                 # The centering ensures the data is found within the 0/0 origin
scaling  <- T                 # The scaling equalizes the data variance to decrease the bias from different data 
                              # intensities
normalization <- peakM$normalizations$TIC  # Choose between TIC/RMS/AcqTic normalizarions. Leave it NA for no normalization

pcaD <-pca(peakM, centering, scaling, normalization)

```

### PC vs PC plots

```{r}
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  # 
save2 <- T     # Select if you want to save the plot into a pdf file (T/F)
fileNpca2 <- "PC1vsPC2.pdf" # Name of the .pdf file

plotly::ggplotly(pca2dimPlot(peakM, pcaD, groupsImg, pc2plot1,pc2plot2, save2, fileNpca2))

```

### PC plots on image

```{r message=FALSE, warning=FALSE}
pc2plot <- 1             # Select which PC to plot into the images
img2plotPca <- 0         # Select which images to plot. Using c() allows you to plot more images at the same time. 
save3 <- F               # Save the plot into a pdf file (T/F)
fileNpca3 <- "PCimg.pdf" # Name of the .pdf file

pcaPlotImg(peakM, matrixList, pcaD, img2plotPca, groupsImg, pc2plot, save3, fileNpca3)
  
```


### K-means

```{r warning=FALSE}
norm4 <- peakM$normalizations$TIC   # Normalization applied to the data
numClusters <- 4                    # Number of cluster to make the k-means

kmeansData <- kmeansCluster(peakM, norm4, numClusters)

```


### K-means segmentation plots

```{r}
img2plot = c(1,3)   # Images you want to ploy. 
save3 = F           # Save the plot into a pdf file (T/F)   
fileName3 = ".pdf"  # Name of the .pdf file

clusterDataPlotting(peakM, matrixList, img2plot, groupsImg, kmeansData, save3, fileName3)


```

