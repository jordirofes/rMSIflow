---
title: "rMSIproc analysis"
author: "Jordi Rofes"
date: "`r Sys.Date()`"
output: html_document
---

### Introduction
rMSI and rMSIproc are R packages that allow the visualization of MALDIims data (rMSI) and the data processing from all the pixel spectrums to a peak matrix (rMSIproc). This tutorial wants to provide a standardized workflow for scientists analyzing different rMSIproc peak matrixs obtained from different images. This tutorial will explain how to: explore the peak matrix to visualize the different m/z intensities on the images, what normalization steps should be utilized when comparing different peak matrix, how to visualize the medium spectrum of the raw data, the application of multidimensional reduction methods (PCA), the utilization of clustering methods like Kmeans and SOM to find clusters of similar spectrums that can be related to differences between different tissue zones and the visualization and comparison of those clusters.

### Required Packages
For this tutorial you will need to install [rMSI](https://github.com/prafols/rMSI), [rMSIproc](https://github.com/prafols/rMSIproc), [ggplot2](), [plotly]() packages if you don't have them.


### rMSI
```{r}
# This function opens the rMSI user interface that allows you to visualize a chosen image
rMSI::OpenMSI()
```
### rMSIproc
```{r}
# This function opens the rMSIproc user interface.
# rMSIproc allows you to input multiple rMSI images to process them (peak peaking, binning, aligning, baseline correction # and calibration) and outputs a compressed file with the peak matrix with the intensities of each mass bin for every    
# pixel on the image  
rMSIproc::ProcessWizard()

```

### Preparations

```{r}

# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/" 

# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"


```


### Extracting the Peak Matrix

```{r results = "hide", echo = "false"}

# Here we extract the Peak Matrix from the .zip and create and object with all the data assigned to peakM
peakM <- rMSIproc::LoadPeakMatrix(file.path(wDir, peakData))


# If your peak matrix is composed of multiple images this will separate them in multiple peak matrix
matrixList <- list()

for(i in 1:length(peakM$numPixels)){
   limitDown <- sum(peakM$numPixels[1:(i-1)])+1
    limitUp <- sum(peakM$numPixels[1:i])
    if(i == 1){limitDown <- 1}
    int <- limitDown:limitUp
 matrixList[[i]] <- rMSIproc::`[.rMSIprocPeakMatrix`(peakM, int)
}

peakM$names 
```

### Order changing

```{r}
# If you are not happy with the order of the images showed on peakM$names you can change it's order by entering here a    # vector with the desired order of images. This will actualize the peakM object with the new order

newOrder <- c(1,2,5,6,3,4) # Insert here the new desired order and run the code chunk. It will require some time to finish
 
matrixList <- matrixList[newOrder]
peakM <- rMSIproc::MergePeakMatrices(matrixList)
```


###  Assigning groups

```{r}
# To allow classification of the images in different groups you will need to insert the names of each group in the vector groupsImg in order as they are on the peak matrix

peakM$names # This allows you to see the order of the images on the peak matrix

# Insert the group for each image (control, control, problem, ...) in the order they are on the peak matrix
# Note # If left empty each image will be named as especified on peakM$names.
groupsImg <- c("Control1", "Control2", "Transition1", "Transition2", "Tumor1", "Tumor2")



if(groupsImg != length(peakM$names)){
  stop("Be careful. The number of groups is not equal to the number of images. Every image should have a group assigned")
}

```


### Exploring the peak matrix

```{r echo=FALSE, warning=FALSE}

# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 100       # Tip # You can find all the mz in your data using peakM$mass
img2plot <- c(1,3)   # Tip # Writing a vector c() allows you to plot more images at the same time
normalization <- NA  # Choose between TIC/AcqTic/RMS normalizations // Leave it as NA for no normalization.
save <- T            # Choose if you want to save the plots into a pdf file
fileN <- "plotsA.pdf"      # Choose the name of the pdf file. Remember if you use the same name, the last one will be   
                     # overwritten
  
plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg, normalization, save, fileN)
plotly::subplot(plots)


```

### Normalizations

Data normalization is a key step to remove part of the systematical error so the data represents more the biological variation
  There are several ways to normalize the data:
     TIC (Total Ion Count): 
     AcqTic (Acquired TIC):
     RMS (Root Mean Squares):


### Medium Spectrum from raw data

```{r}
# We can use rMSI functions to plot the average spectra of an image to explore the raw data
# First you will need to put the .tar of the images on the same directory you are working on

bad <- list.files(wDir, pattern = "^ramdisk")
imageName <- list.files(wDir, pattern = "proc.tar")
imageName <- imageName[!(imageName %in% bad)]

# Then we run the code so it extracts the image information and calculates the average spectrum
avSpec <- lapply(imageName, function(name){
  image <- rMSI::LoadMsiData(file.path(wDir, name))
  mass <- image$mass
  aS <- rMSIproc::AverageSpectrum(image) 
  spect <- cbind(mass, aS)
  return(spect)
})

avSepcData <- data.frame(avSpec)
# row.names(avSepcData) <- imageName
# colnames(avSepcData) <- image$mass

 
```

```{r}
# Here we plot the average spectrums we want to compare

library(ggplot2)
library(plotly)
ggplotly(ggplot2::ggplot(avSepcData) + geom_line(aes(x = mass, y = aS), colour = "red"))
# +
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.1),colour = "blue")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.2),colour = "yellow")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.3),colour = "green")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.4),colour = "orange")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.5),colour = "black")+ xlab("M/Z") + ylab("Intensity"))
#rMSI::plotSpectra(mass = image$mass, intensity = avSpec1)
```



### PCA

```{r echo=FALSE, message=FALSE, warning=FALSE}
centering<- T 
scaling  <- T
normalization <- NA


pcaD <-pca(peakMatrix = peakM, centering, scaling, groupsImg, normalization)


```

### PC vs PC plots

```{r}
pc2plot1 <- 1  # Select which PC are going to be plotted in a two dimensional graphic
pc2plot2 <- 2  # 
save <- T
fileNpca <- "PC1vsPC2.pdf"

pca2dimPlot(peakM, pcaD, groupsImg, pc2plot1,pc2plot2,save, fileNpca)

```

### PC plots on image

```{r}
pc2plot <-
img2plotPca <-
save <- 
fileNpca2 <- "PC1xaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq qqqwwwwwwwwwccccccccccccccccccccccccccccccccccccccccccccccccqaz<.pdf"
  
```


### Medium spectrum from peak matrix
```{r}
pixels2calculate <- c(1:50)
normalization <- ""
medSpec(peakM, pixels2calculate, normalization)


```

### K-means

```{r warning=FALSE}

dataNormTic <- peakM$intensity/peakM$normalizations$TIC ### Dividim les intensitats pel factor de normalitzaciÃ³ TIC 

clData <- vector(mode = "list",length = length(peakM$numPixels)) 

for (i in 1:length(peakM$numPixels)){ 
 if (i == 1){
    clData[i] <- list(kmeans(dataNormTic[1:peakM$numPixels[i], ], 5))
 } else {
    clData[i] <- list(kmeans(dataNormTic[(sum(peakM$numPixels[1:(i-1)])+1):sum(peakM$numPixels[1:i]), ], 5))
 }
}

clusImages <- lapply(clData, function(x){
  return(x[1]) 
})

allClusImages <- unlist(clusImages)


plotly::ggplotly(rMSIproc::plotValuesImageG(peakM, allClusImages))

```













