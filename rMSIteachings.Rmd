---
title: "rMSIproc analysis"
author: "Jordi Rofes"
date: "`r Sys.Date()`"
output: html_document
---

### Introduction



### Preparations

```{r}

# Insert where your data is located (The peak matrix and the .tar images)
wDir <- "C:/Users/jordi/Desktop/Metabolomica/Projecte MALDI/CollCap/" 

# Insert the name of the peak matrix .zip
peakData <- "mergeddata-peaks.zip"

# Insert the group for each image (control, control, problem, ...) in order
groupsImg <- c("Control1", "Control2", "Transition1", "Transition1", "Tumor1", "Tumor2")

```

### Extracting the Peak Matrix

```{r results = "hide", echo = "false", include=matrixSeparation}

# Here we extract the Peak Matrix from the .zip and create and object with all the data assigned to peakM
peakM <- rMSIproc::LoadPeakMatrix(file.path(wDir, peakData))



# If your peak matrix is composed of multiple images this will separate them in multiple peak matrix
matrixList <- list()

for(i in 1:length(peakM$numPixels)){
   limitDown <- sum(peakM$numPixels[1:(i-1)])+1
    limitUp <- sum(peakM$numPixels[1:i])
    if(i == 1){limitDown <- 1}
    int <- limitDown:limitUp
 matrixList[[i]] <- rMSIproc::`[.rMSIprocPeakMatrix`(peakM, int)
}


```

### Exploring the peak matrix

```{r warnings= "hide"}

# Select m/z to plot and image number out of peakM$names to plot
peakM$names
mz2plot <- 377       #Tip# You can find all the mz in your data at peakM$mass
img2plot <- c(6)   #Tip# Writing a vector c() allows you to plot more images at the same time


plots <- initialPlotter(peakM, matrixList, mz2plot,img2plot, groupsImg)

pl <- lapply(1:length(img2plot), function(i){
  plotly::ggplotly(p = plots[[i]])
})
plotly::subplot(pl)



```

### Normalizations

Data normalization is a key step to remove part of the systematical error so the data represents more the biological variation
  There are several ways to normalize the data:
     TIC (Total Ion Count): 
     aqTIC (aquired TIC)
     RMS ()

```{r}
mz <- 400
rMSIproc::plotPeakImage(matrixList[[1]], mz, labels = groupsImg[1])
rMSIproc::plotPeakImage(matrixList[[1]], mz, labels = groupsImg[1],normalization = "TIC")
rMSIproc::plotPeakImage(matrixList[[1]], mz, labels = groupsImg[1],normalization = "RMS")
rMSIproc::plotPeakImage(matrixList[[1]], mz, labels = groupsImg[1],normalization = "AcqTic")

#pl <- plotly::ggplotly(rMSIproc::plotPeakImageG(matrixList[[1]], mz, plot_labels = groupsImg[1]))
#pl2 <- plotly::ggplotly(rMSIproc::plotPeakImageG(matrixList[[1]], mz, plot_labels = groupsImg[1], normalization = "TIC"))
#plotly::subplot(pl, pl2)

```

### Medium Spectrum

```{r}
# We can use rMSI functions to plot the average spectra of an image to explore the raw data
# First you will need to put the .tar of the images on the same directory you are working on

bad <- list.files(wDir, pattern = "^ramdisk")
imageName <- list.files(wDir, pattern = "proc.tar")
imageName <- imageName[!(imageName %in% bad)]

# Then we run the code so it extracts the image information and calculates de average spectrum
avSpec <- lapply(imageName, function(name){
  image <- rMSI::LoadMsiData(file.path(wDir, name))
  mass <- image$mass
  aS <- rMSIproc::AverageSpectrum(image) 
  spect <- cbind(mass, aS)
  return(spect)
})

avSepcData <- data.frame(avSpec)
# row.names(avSepcData) <- imageName
# colnames(avSepcData) <- image$mass

```

```{r}
# Here we plot the average spectrums we want to compare

library(ggplot2)
library(plotly)
ggplotly(ggplot2::ggplot(avSepcData) + geom_line(aes(x = mass, y = aS), colour = "red"))
# +
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.1),colour = "blue")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.2),colour = "yellow")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.3),colour = "green")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.4),colour = "orange")+
#                    geom_line(aes(x = avSepcData$mass, y = avSepcData$aS.5),colour = "black")+ xlab("M/Z") + ylab("Intensity"))
#rMSI::plotSpectra(mass = image$mass, intensity = avSpec1)
```



### PCA de dades sense normalitzar

```{r }

dataRaw <- peakM$intensity 
colnames(dataRaw) <- peakM$mass
pcaRaw <- prcomp(dataRaw, center = T, scale. = T) ### Fem la PCA de la matriu de pics

listGroups <- mapply(function(groups,i){
  rep(groups,  peakM$numPixels[i])
}, groupsImg, 1:length(groupsImg))

vectorGroups <- unlist(listGroups)

pcaData <- list()
pcaData[[1]] <- pcaRaw$x[,1]
pcaData[[2]] <- pcaRaw$x[,2]
pcaData[[3]] <- vectorGroups
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:5333)

ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) + xlab("PC1") + ylab("PC2")

```

### PCA de dades normalitzades per TIC

```{r}
dataNormTic <- peakM$intensity/peakM$normalizations$TIC ### Dividim les intensitats pel factor de normalització TIC 
pcaNormTic <- prcomp(dataNormTic, center = T, scale = T)
 
pcaData <- list()
pcaData[[1]] <- pcaNormTic$x[,1]
pcaData[[2]] <- pcaNormTic$x[,2]
pcaData[[3]] <- vectorGroups
dataPca <- as.data.frame(pcaData)
colnames(dataPca) <- c("PC1", "PC2", "Groups")
rownames(dataPca) <- c(1:5333)

ggplot(dataPca)+ geom_point(aes(x = PC1, y = PC2, colour = Groups), alpha = 0.5) + xlab("PC1") + ylab("PC2")


 #rMSIproc::plotValuesImage(peakM, pcaRaw$x[,1])
 #rMSIproc::plotValuesImage(peakM, pcaNormTic$x[,1])
 


```

### K-means

```{r warning=FALSE}

dataNormTic <- peakM$intensity/peakM$normalizations$TIC ### Dividim les intensitats pel factor de normalització TIC 

clData <- vector(mode = "list",length = length(peakM$numPixels)) 

for (i in 1:length(peakM$numPixels)){ 
 if (i == 1){
    clData[i] <- list(kmeans(dataNormTic[1:peakM$numPixels[i], ], 2))
 } else {
    clData[i] <- list(kmeans(dataNormTic[(sum(peakM$numPixels[1:(i-1)])+1):sum(peakM$numPixels[1:i]), ], 2))
 }
}

clusImages <- lapply(clData, function(x){
  return(x[1]) 
})

allClusImages <- unlist(clusImages)


rMSIproc::plotValuesImage(peakM, allClusImages)

```


### Finding gold peaks

```{r}
## This function searches the peak matrix for the intensities of the peaks related
auTList <- c(196.966570, 393.933140, 590.899710, 787.866280, 984.832850)

rmIndex <- lapply(auTList, function(tMass){
  diffMatrix <- (abs(peakM$mass - tMass))
  index <- which.min(diffMatrix)
  return(index) ## This will return the masses where the gold peaks are based on the real mass                                                 ## with the minimum difference with the teorical mass
  })
rmIndex <- unlist(rMass)
auMass <- peakM$mass[rmIndex]

## All intensities from every Au peak
aupeakMatrix <- peakM$intensity[,rMass]
colnames(aupeakMatrix) <- c("Au1", "Au2","Au3", "Au4","Au5")

```

### Calculating Au intensity quocients

```{r}
# Mean intensities by image
meanImagePeakAu <- matrix(nrow = length(peakM$numPixels), ncol = length(auMass))

for(i in 1:length(peakM$numPixels)){
  for(z in 1:length(auTList)){
    
     limitDown <- sum(peakM$numPixels[1:(i-1)])+1
    limitUp <- sum(peakM$numPixels[1:i])
    if(i == 1){limitDown <- 1}
    int <- limitDown:limitUp
  
    meanImagePeakAu[i,z] <-  mean(aupeakMatrix[int, z])
  }
colnames(meanImagePeakAu) <- c("Au1", "Au2","Au3", "Au4","Au5")
}


```










